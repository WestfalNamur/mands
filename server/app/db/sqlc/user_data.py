
# Code generated by sqlc. DO NOT EDIT.
from typing import AsyncIterator, Iterator, Optional

import sqlalchemy
import sqlalchemy.ext.asyncio

from db import models


ADD_USER_DATA = """-- name: add_user_data \\:one
INSERT INTO user_data (
    user_name,
    user_password
) VALUES (
    :p1, :p2
) RETURNING id, user_name, user_password
"""


DELETE_USER_DATA = """-- name: delete_user_data \\:exec
DELETE FROM user_data
WHERE id = :p1
"""


GET_ALL_USER_DATA = """-- name: get_all_user_data \\:many
SELECT id, user_name, user_password FROM user_data
ORDER BY id
LIMIT :p1
OFFSET :p2
"""


GET_USER_DATA = """-- name: get_user_data \\:one
SELECT id, user_name, user_password FROM user_data
WHERE id = :p1
"""


UPDATE_USER_DATA = """-- name: update_user_data \\:one
UPDATE user_data
SET user_name = :p2,
    user_password = :p3
WHERE id = :p1 
RETURNING id, user_name, user_password
"""


class Querier:
    def __init__(self, conn: sqlalchemy.engine.Connection):
        self._conn = conn

    def add_user_data(self, *, user_name: str, user_password: str) -> Optional[models.UserDatum]:
        row = self._conn.execute(sqlalchemy.text(ADD_USER_DATA), {"p1": user_name, "p2": user_password}).first()
        if row is None:
            return None
        return models.UserDatum(
            id=row[0],
            user_name=row[1],
            user_password=row[2],
        )

    def delete_user_data(self, *, id: int) -> None:
        self._conn.execute(sqlalchemy.text(DELETE_USER_DATA), {"p1": id})

    def get_all_user_data(self, *, limit: int, offset: int) -> Iterator[models.UserDatum]:
        result = self._conn.execute(sqlalchemy.text(GET_ALL_USER_DATA), {"p1": limit, "p2": offset})
        for row in result:
            yield models.UserDatum(
                id=row[0],
                user_name=row[1],
                user_password=row[2],
            )

    def get_user_data(self, *, id: int) -> Optional[models.UserDatum]:
        row = self._conn.execute(sqlalchemy.text(GET_USER_DATA), {"p1": id}).first()
        if row is None:
            return None
        return models.UserDatum(
            id=row[0],
            user_name=row[1],
            user_password=row[2],
        )

    def update_user_data(self, *, id: int, user_name: str, user_password: str) -> Optional[models.UserDatum]:
        row = self._conn.execute(sqlalchemy.text(UPDATE_USER_DATA), {"p1": id, "p2": user_name, "p3": user_password}).first()
        if row is None:
            return None
        return models.UserDatum(
            id=row[0],
            user_name=row[1],
            user_password=row[2],
        )


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def add_user_data(self, *, user_name: str, user_password: str) -> Optional[models.UserDatum]:
        row = (await self._conn.execute(sqlalchemy.text(ADD_USER_DATA), {"p1": user_name, "p2": user_password})).first()
        if row is None:
            return None
        return models.UserDatum(
            id=row[0],
            user_name=row[1],
            user_password=row[2],
        )

    async def delete_user_data(self, *, id: int) -> None:
        await self._conn.execute(sqlalchemy.text(DELETE_USER_DATA), {"p1": id})

    async def get_all_user_data(self, *, limit: int, offset: int) -> AsyncIterator[models.UserDatum]:
        result = await self._conn.stream(sqlalchemy.text(GET_ALL_USER_DATA), {"p1": limit, "p2": offset})
        async for row in result:
            yield models.UserDatum(
                id=row[0],
                user_name=row[1],
                user_password=row[2],
            )

    async def get_user_data(self, *, id: int) -> Optional[models.UserDatum]:
        row = (await self._conn.execute(sqlalchemy.text(GET_USER_DATA), {"p1": id})).first()
        if row is None:
            return None
        return models.UserDatum(
            id=row[0],
            user_name=row[1],
            user_password=row[2],
        )

    async def update_user_data(self, *, id: int, user_name: str, user_password: str) -> Optional[models.UserDatum]:
        row = (await self._conn.execute(sqlalchemy.text(UPDATE_USER_DATA), {"p1": id, "p2": user_name, "p3": user_password})).first()
        if row is None:
            return None
        return models.UserDatum(
            id=row[0],
            user_name=row[1],
            user_password=row[2],
        )

